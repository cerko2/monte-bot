<html lang="en">
<head>
<title>Sparse Linear Algebra - Untitled</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Untitled">
<meta name="generator" content="makeinfo 4.7">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Sparse-Matrices.html#Sparse-Matrices" title="Sparse Matrices">
<link rel="prev" href="Basics.html#Basics" title="Basics">
<link rel="next" href="Iterative-Techniques.html#Iterative-Techniques" title="Iterative Techniques">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc { font-variant:small-caps }
  span.roman { font-family: serif; font-weight: normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Sparse-Linear-Algebra"></a>Next:&nbsp;<a rel="next" accesskey="n" href="Iterative-Techniques.html#Iterative-Techniques">Iterative Techniques</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Basics.html#Basics">Basics</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Sparse-Matrices.html#Sparse-Matrices">Sparse Matrices</a>
<hr><br>
</div>

<h3 class="section">21.2 Linear Algebra on Sparse Matrices</h3>

<p>Octave includes a polymorphic solver for sparse matrices, where
the exact solver used to factorize the matrix, depends on the properties
of the sparse matrix itself.  Generally, the cost of determining the matrix type
is small relative to the cost of factorizing the matrix itself, but in any
case the matrix type is cached once it is calculated, so that it is not
re-determined each time it is used in a linear equation.

   <p>The selection tree for how the linear equation is solve is

     <ol type=1 start=1>
<li>If the matrix is diagonal, solve directly and goto 8

     <li>If the matrix is a permuted diagonal, solve directly taking into
account the permutations.  Goto 8

     <li>If the matrix is square, banded and if the band density is less
than that given by <code>spparms ("bandden")</code> continue, else goto 4.

          <ol type=a start=1>
<li>If the matrix is tridiagonal and the right-hand side is not sparse
continue, else goto 3b.

               <ol type=1 start=1>
<li>If the matrix is hermitian, with a positive real diagonal, attempt
      Cholesky factorization using <span class="sc">lapack</span> xPTSV.

               <li>If the above failed or the matrix is not hermitian with a positive
      real diagonal use Gaussian elimination with pivoting using
      <span class="sc">lapack</span> xGTSV, and goto 8.
               </ol>

          <li>If the matrix is hermitian with a positive real diagonal, attempt
      Cholesky factorization using <span class="sc">lapack</span> xPBTRF.

          <li>if the above failed or the matrix is not hermitian with a positive
      real diagonal use Gaussian elimination with pivoting using
      <span class="sc">lapack</span> xGBTRF, and goto 8.
          </ol>

     <li>If the matrix is upper or lower triangular perform a sparse forward
or backward substitution, and goto 8

     <li>If the matrix is a upper triangular matrix with column permutations
or lower triangular matrix with row permutations, perform a sparse forward
or backward substitution, and goto 8

     <li>If the matrix is square, hermitian with a real positive diagonal, attempt
sparse Cholesky factorization using CHOLMOD.

     <li>If the sparse Cholesky factorization failed or the matrix is not
hermitian with a real positive diagonal, and the matrix is square, factorize
using UMFPACK.

     <li>If the matrix is not square, or any of the previous solvers flags
a singular or near singular matrix, find a minimum norm solution using
CXSPARSE<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>.
        </ol>

   <p>The band density is defined as the number of non-zero values in the matrix
divided by the number of non-zero values in the matrix.  The banded matrix
solvers can be entirely disabled by using <dfn>spparms</dfn> to set <code>bandden</code>
to 1 (i.e., <code>spparms ("bandden", 1)</code>).

   <p>The QR solver factorizes the problem with a Dulmage-Mendelsohn, to
separate the problem into blocks that can be treated as over-determined,
multiple well determined blocks, and a final over-determined block.  For
matrices with blocks of strongly connected nodes this is a big win as
LU decomposition can be used for many blocks.  It also significantly
improves the chance of finding a solution to over-determined problems
rather than just returning a vector of <dfn>NaN</dfn>'s.

   <p>All of the solvers above, can calculate an estimate of the condition
number.  This can be used to detect numerical stability problems in the
solution and force a minimum norm solution to be used.  However, for
narrow banded, triangular or diagonal matrices, the cost of
calculating the condition number is significant, and can in fact
exceed the cost of factoring the matrix.  Therefore the condition
number is not calculated in these cases, and Octave relies on simpler
techniques to detect singular matrices or the underlying <span class="sc">lapack</span> code in
the case of banded matrices.

   <p>The user can force the type of the matrix with the <code>matrix_type</code>
function.  This overcomes the cost of discovering the type of the matrix. 
However, it should be noted that identifying the type of the matrix incorrectly
will lead to unpredictable results, and so <code>matrix_type</code> should be
used with care.

<!-- ./sparse/normest.m -->
<p><a name="doc_002dnormest"></a>

<div class="defun">
&mdash; Function File: [<var>n</var>, <var>c</var>] = <b>normest</b> (<var>a, tol</var>)<var><a name="index-normest-1709"></a></var><br>
<blockquote><p>Estimate the 2-norm of the matrix <var>a</var> using a power series
analysis.  This is typically used for large matrices, where the cost
of calculating the <code>norm (</code><var>a</var><code>)</code> is prohibitive and an approximation
to the 2-norm is acceptable.

        <p><var>tol</var> is the tolerance to which the 2-norm is calculated.  By default
<var>tol</var> is 1e-6.  <var>c</var> returns the number of iterations needed for
<code>normest</code> to converge. 
</p></blockquote></div>

<!-- ./linear-algebra/onenormest.m -->
<p><a name="doc_002donenormest"></a>

<div class="defun">
&mdash; Function File: [<var>est</var>, <var>v</var>, <var>w</var>, <var>iter</var>] = <b>onenormest</b> (<var>a, t</var>)<var><a name="index-onenormest-1710"></a></var><br>
&mdash; Function File: [<var>est</var>, <var>v</var>, <var>w</var>, <var>iter</var>] = <b>onenormest</b> (<var>apply, apply_t, n, t</var>)<var><a name="index-onenormest-1711"></a></var><br>
<blockquote>
<p>Apply Higham and Tisseur's randomized block 1-norm estimator to
matrix <var>a</var> using <var>t</var> test vectors.  If <var>t</var> exceeds 5, then
only 5 test vectors are used.

        <p>If the matrix is not explicit, e.g., when estimating the norm of
<code>inv (</code><var>A</var><code>)</code> given an LU factorization, <code>onenormest</code> applies
<var>A</var> and its conjugate transpose through a pair of functions
<var>apply</var> and <var>apply_t</var>, respectively, to a dense matrix of size
<var>n</var> by <var>t</var>.  The implicit version requires an explicit dimension
<var>n</var>.

        <p>Returns the norm estimate <var>est</var>, two vectors <var>v</var> and
<var>w</var> related by norm
<code>(</code><var>w</var><code>, 1) = </code><var>est</var><code> * norm (</code><var>v</var><code>, 1)</code>,
and the number of iterations <var>iter</var>.  The number of
iterations is limited to 10 and is at least 2.

        <p>References:
          <ul>
<li>Nicholas J. Higham and Françoise Tisseur, "A Block Algorithm
for Matrix 1-Norm Estimation, with an Application to 1-Norm
Pseudospectra." SIMAX vol 21, no 4, pp 1185-1201. 
<a href="http://dx.doi.org/10.1137/S0895479899356080">http://dx.doi.org/10.1137/S0895479899356080</a>
<li>Nicholas J. Higham and Françoise Tisseur, "A Block Algorithm
for Matrix 1-Norm Estimation, with an Application to 1-Norm
Pseudospectra." <a href="http://citeseer.ist.psu.edu/223007.html">http://citeseer.ist.psu.edu/223007.html</a>
</ul>

     <!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->
<p class="noindent"><strong>See also:</strong> <a href="doc_002dcondest.html#doc_002dcondest">condest</a>, <a href="doc_002dnorm.html#doc_002dnorm">norm</a>, <a href="doc_002dcond.html#doc_002dcond">cond</a>. 
</p></blockquote></div>

<!-- ./linear-algebra/condest.m -->
<p><a name="doc_002dcondest"></a>

<div class="defun">
&mdash; Function File: [<var>est</var>, <var>v</var>] = <b>condest</b> (<var>a, t</var>)<var><a name="index-condest-1712"></a></var><br>
&mdash; Function File: [<var>est</var>, <var>v</var>] = <b>condest</b> (<var>a, solve, solve_t, t</var>)<var><a name="index-condest-1713"></a></var><br>
&mdash; Function File: [<var>est</var>, <var>v</var>] = <b>condest</b> (<var>apply, apply_t, solve, solve_t, n, t</var>)<var><a name="index-condest-1714"></a></var><br>
<blockquote>
<p>Estimate the 1-norm condition number of a matrix <var>A</var>
using <var>t</var> test vectors using a randomized 1-norm estimator. 
If <var>t</var> exceeds 5, then only 5 test vectors are used.

        <p>If the matrix is not explicit, e.g., when estimating the condition
number of <var>a</var> given an LU factorization, <code>condest</code> uses the
following functions:

          <dl>
<dt><var>apply</var><dd><code>A*x</code> for a matrix <code>x</code> of size <var>n</var> by <var>t</var>. 
<br><dt><var>apply_t</var><dd><code>A'*x</code> for a matrix <code>x</code> of size <var>n</var> by <var>t</var>. 
<br><dt><var>solve</var><dd><code>A \ b</code> for a matrix <code>b</code> of size <var>n</var> by <var>t</var>. 
<br><dt><var>solve_t</var><dd><code>A' \ b</code> for a matrix <code>b</code> of size <var>n</var> by <var>t</var>. 
</dl>

        <p>The implicit version requires an explicit dimension <var>n</var>.

        <p><code>condest</code> uses a randomized algorithm to approximate
the 1-norms.

        <p><code>condest</code> returns the 1-norm condition estimate <var>est</var> and
a vector <var>v</var> satisfying <code>norm (A*v, 1) == norm (A, 1) * norm
(</code><var>v</var><code>, 1) / </code><var>est</var>.  When <var>est</var> is large, <var>v</var> is an
approximate null vector.

        <p>References:
          <ul>
<li>Nicholas J. Higham and Françoise Tisseur, "A Block Algorithm
for Matrix 1-Norm Estimation, with an Application to 1-Norm
Pseudospectra." SIMAX vol 21, no 4, pp 1185-1201. 
<a href="http://dx.doi.org/10.1137/S0895479899356080">http://dx.doi.org/10.1137/S0895479899356080</a>
<li>Nicholas J. Higham and Françoise Tisseur, "A Block Algorithm
for Matrix 1-Norm Estimation, with an Application to 1-Norm
Pseudospectra." <a href="http://citeseer.ist.psu.edu/223007.html">http://citeseer.ist.psu.edu/223007.html</a>
</ul>

     <!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->
<p class="noindent"><strong>See also:</strong> <a href="doc_002dcond.html#doc_002dcond">cond</a>, <a href="doc_002dnorm.html#doc_002dnorm">norm</a>, <a href="doc_002donenormest.html#doc_002donenormest">onenormest</a>. 
</p></blockquote></div>

<!-- ./DLD-FUNCTIONS/spparms.cc -->
<p><a name="doc_002dspparms"></a>

<div class="defun">
&mdash; Loadable Function:  <b>spparms</b> ()<var><a name="index-spparms-1715"></a></var><br>
&mdash; Loadable Function: <var>vals</var> = <b>spparms</b> ()<var><a name="index-spparms-1716"></a></var><br>
&mdash; Loadable Function: [<var>keys</var>, <var>vals</var>] = <b>spparms</b> ()<var><a name="index-spparms-1717"></a></var><br>
&mdash; Loadable Function: <var>val</var> = <b>spparms</b> (<var>key</var>)<var><a name="index-spparms-1718"></a></var><br>
&mdash; Loadable Function:  <b>spparms</b> (<var>vals</var>)<var><a name="index-spparms-1719"></a></var><br>
&mdash; Loadable Function:  <b>spparms</b> (<var>'defaults'</var>)<var><a name="index-spparms-1720"></a></var><br>
&mdash; Loadable Function:  <b>spparms</b> (<var>'tight'</var>)<var><a name="index-spparms-1721"></a></var><br>
&mdash; Loadable Function:  <b>spparms</b> (<var>key, val</var>)<var><a name="index-spparms-1722"></a></var><br>
<blockquote><p>Sets or displays the parameters used by the sparse solvers and factorization
functions.  The first four calls above get information about the current
settings, while the others change the current settings.  The parameters are
stored as pairs of keys and values, where the values are all floats and the
keys are one of the following strings:

          <dl>
<dt><code>spumoni</code><dd>Printing level of debugging information of the solvers (default 0)
<br><dt><code>ths_rel</code><dd>Included for compatibility.  Not used.  (default 1)
<br><dt><code>ths_abs</code><dd>Included for compatibility.  Not used.  (default 1)
<br><dt><code>exact_d</code><dd>Included for compatibility.  Not used.  (default 0)
<br><dt><code>supernd</code><dd>Included for compatibility.  Not used.  (default 3)
<br><dt><code>rreduce</code><dd>Included for compatibility.  Not used.  (default 3)
<br><dt><code>wh_frac</code><dd>Included for compatibility.  Not used.  (default 0.5)
<br><dt><code>autommd</code><dd>Flag whether the LU/QR and the '\' and '/' operators will automatically
use the sparsity preserving mmd functions (default 1)
<br><dt><code>autoamd</code><dd>Flag whether the LU and the '\' and '/' operators will automatically
use the sparsity preserving amd functions (default 1)
<br><dt><code>piv_tol</code><dd>The pivot tolerance of the UMFPACK solvers (default 0.1)
<br><dt><code>sym_tol</code><dd>The pivot tolerance of the UMFPACK symmetric solvers (default 0.001)
<br><dt><code>bandden</code><dd>The density of non-zero elements in a banded matrix before it is treated
by the <span class="sc">lapack</span> banded solvers (default 0.5)
<br><dt><code>umfpack</code><dd>Flag whether the UMFPACK or mmd solvers are used for the LU, '\' and
'/' operations (default 1)
</dl>

        <p>The value of individual keys can be set with <code>spparms (</code><var>key</var><code>,
</code><var>val</var><code>)</code>.  The default values can be restored with the special keyword
'defaults'.  The special keyword 'tight' can be used to set the mmd solvers
to attempt for a sparser solution at the potential cost of longer running
time. 
</p></blockquote></div>

<!-- ./DLD-FUNCTIONS/dmperm.cc -->
<p><a name="doc_002dsprank"></a>

<div class="defun">
&mdash; Loadable Function: <var>p</var> = <b>sprank</b> (<var>s</var>)<var><a name="index-sprank-1723"></a></var><br>
<blockquote>
<p><a name="index-Structural-Rank-1724"></a>Calculates the structural rank of a sparse matrix <var>s</var>.  Note that
only the structure of the matrix is used in this calculation based on
a Dulmage-Mendelsohn permutation to block triangular form.  As such the numerical
rank of the matrix <var>s</var> is bounded by <code>sprank (</code><var>s</var><code>) &gt;=
rank (</code><var>s</var><code>)</code>.  Ignoring floating point errors <code>sprank (</code><var>s</var><code>) ==
rank (</code><var>s</var><code>)</code>. 
<!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

     <p class="noindent"><strong>See also:</strong> <a href="doc_002ddmperm.html#doc_002ddmperm">dmperm</a>. 
</p></blockquote></div>

<!-- ./DLD-FUNCTIONS/symbfact.cc -->
<p><a name="doc_002dsymbfact"></a>

<div class="defun">
&mdash; Loadable Function: [<var>count</var>, <var>h</var>, <var>parent</var>, <var>post</var>, <var>r</var>] = <b>symbfact</b> (<var>s, typ, mode</var>)<var><a name="index-symbfact-1725"></a></var><br>
<blockquote>
<p>Performs a symbolic factorization analysis on the sparse matrix <var>s</var>. 
Where

          <dl>
<dt><var>s</var><dd><var>s</var> is a complex or real sparse matrix.

          <br><dt><var>typ</var><dd>Is the type of the factorization and can be one of

               <dl>
<dt><code>sym</code><dd>Factorize <var>s</var>.  This is the default.

               <br><dt><code>col</code><dd>Factorize <var>s</var><code>' * </code><var>s</var>. 
<br><dt><code>row</code><dd>Factorize <var>s</var><code> * </code><var>s</var><code>'</code>. 
<br><dt><code>lo</code><dd>Factorize <var>s</var><code>'</code>
</dl>

          <br><dt><var>mode</var><dd>The default is to return the Cholesky factorization for <var>r</var>, and if
<var>mode</var> is 'L', the conjugate transpose of the Cholesky factorization
is returned.  The conjugate transpose version is faster and uses less
memory, but returns the same values for <var>count</var>, <var>h</var>, <var>parent</var>
and <var>post</var> outputs. 
</dl>

        <p>The output variables are

          <dl>
<dt><var>count</var><dd>The row counts of the Cholesky factorization as determined by <var>typ</var>.

          <br><dt><var>h</var><dd>The height of the elimination tree.

          <br><dt><var>parent</var><dd>The elimination tree itself.

          <br><dt><var>post</var><dd>A sparse boolean matrix whose structure is that of the Cholesky
factorization as determined by <var>typ</var>. 
</dl>
        </p></blockquote></div>

   <p>For non square matrices, the user can also utilize the <code>spaugment</code>
function to find a least squares solution to a linear equation.

<!-- ./sparse/spaugment.m -->
<p><a name="doc_002dspaugment"></a>

<div class="defun">
&mdash; Function File: <var>s</var> = <b>spaugment</b> (<var>a, c</var>)<var><a name="index-spaugment-1726"></a></var><br>
<blockquote><p>Creates the augmented matrix of <var>a</var>.  This is given by

     <pre class="example">          [<var>c</var> * eye(<var>m</var>, <var>m</var>),<var>a</var>; <var>a</var>', zeros(<var>n</var>,
          <var>n</var>)]
     </pre>
        <p class="noindent">This is related to the least squares solution of
<var>a</var><code> \\ </code><var>b</var>, by

     <pre class="example">          <var>s</var> * [ <var>r</var> / <var>c</var>; x] = [<var>b</var>, zeros(<var>n</var>,
          columns(<var>b</var>)]
     </pre>
        <p class="noindent">where <var>r</var> is the residual error

     <pre class="example">          <var>r</var> = <var>b</var> - <var>a</var> * <var>x</var>
     </pre>
        <p>As the matrix <var>s</var> is symmetric indefinite it can be factorized
with <code>lu</code>, and the minimum norm solution can therefore be found
without the need for a <code>qr</code> factorization.  As the residual
error will be <code>zeros (</code><var>m</var><code>, </code><var>m</var><code>)</code> for under determined
problems, and example can be

     <pre class="example">          m = 11; n = 10; mn = max(m ,n);
          a = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],
                       [-1, 0, 1], m, n);
          x0 = a \ ones (m,1);
          s = spaugment (a);
          [L, U, P, Q] = lu (s);
          x1 = Q * (U \ (L \ (P  * [ones(m,1); zeros(n,1)])));
          x1 = x1(end - n + 1 : end);
     </pre>
        <p>To find the solution of an overdetermined problem needs an estimate
of the residual error <var>r</var> and so it is more complex to formulate
a minimum norm solution using the <code>spaugment</code> function.

        <p>In general the left division operator is more stable and faster than
using the <code>spaugment</code> function. 
</p></blockquote></div>

   <p>Finally, the function <code>eigs</code> can be used to calculate a limited
number of eigenvalues and eigenvectors based on a selection criteria
and likewise for <code>svds</code> which calculates a limited number of
singular values and vectors.

<!-- ./DLD-FUNCTIONS/eigs.cc -->
<p><a name="doc_002deigs"></a>

<div class="defun">
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>a</var>)<var><a name="index-_003d-1727"></a></var><br>
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>a, k</var>)<var><a name="index-_003d-1728"></a></var><br>
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>a, k, sigma</var>)<var><a name="index-_003d-1729"></a></var><br>
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>a, k, sigma,opts</var>)<var><a name="index-_003d-1730"></a></var><br>
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>a, b</var>)<var><a name="index-_003d-1731"></a></var><br>
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>a, b, k</var>)<var><a name="index-_003d-1732"></a></var><br>
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>a, b, k, sigma</var>)<var><a name="index-_003d-1733"></a></var><br>
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>a, b, k, sigma, opts</var>)<var><a name="index-_003d-1734"></a></var><br>
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>af, n</var>)<var><a name="index-_003d-1735"></a></var><br>
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>af, n, b</var>)<var><a name="index-_003d-1736"></a></var><br>
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>af, n, k</var>)<var><a name="index-_003d-1737"></a></var><br>
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>af, n, b, k</var>)<var><a name="index-_003d-1738"></a></var><br>
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>af, n, k, sigma</var>)<var><a name="index-_003d-1739"></a></var><br>
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>af, n, b, k, sigma</var>)<var><a name="index-_003d-1740"></a></var><br>
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>af, n, k, sigma, opts</var>)<var><a name="index-_003d-1741"></a></var><br>
&mdash; Loadable Function: <var>d</var> <b>=</b><var> eigs </var>(<var>af, n, b, k, sigma, opts</var>)<var><a name="index-_003d-1742"></a></var><br>
&mdash; Loadable Function: [<var>v</var>, <var>d</var>] <b>=</b><var> eigs </var>(<var>a, <small class="dots">...</small></var>)<var><a name="index-_003d-1743"></a></var><br>
&mdash; Loadable Function: [<var>v</var>, <var>d</var>] <b>=</b><var> eigs </var>(<var>af, n, <small class="dots">...</small></var>)<var><a name="index-_003d-1744"></a></var><br>
&mdash; Loadable Function: [<var>v</var>, <var>d</var>, <var>flag</var>] <b>=</b><var> eigs </var>(<var>a, <small class="dots">...</small></var>)<var><a name="index-_003d-1745"></a></var><br>
&mdash; Loadable Function: [<var>v</var>, <var>d</var>, <var>flag</var>] <b>=</b><var> eigs </var>(<var>af, n, <small class="dots">...</small></var>)<var><a name="index-_003d-1746"></a></var><br>
<blockquote><p>Calculate a limited number of eigenvalues and eigenvectors of <var>a</var>,
based on a selection criteria.  The number eigenvalues and eigenvectors to
calculate is given by <var>k</var> whose default value is 6.

        <p>By default <code>eigs</code> solve the equation
<code>A * v = lambda * v</code>
, where
<code>lambda</code> is a scalar representing one of the eigenvalues, and <code>v</code>
is the corresponding eigenvector.  If given the positive definite matrix
<var>B</var> then <code>eigs</code> solves the general eigenvalue equation
<code>A * v = lambda * B * v</code>
.

        <p>The argument <var>sigma</var> determines which eigenvalues are returned. 
<var>sigma</var> can be either a scalar or a string.  When <var>sigma</var> is a scalar,
the <var>k</var> eigenvalues closest to <var>sigma</var> are returned.  If <var>sigma</var>
is a string, it must have one of the values

          <dl>
<dt>'lm'<dd>Largest magnitude (default).

          <br><dt>'sm'<dd>Smallest magnitude.

          <br><dt>'la'<dd>Largest Algebraic (valid only for real symmetric problems).

          <br><dt>'sa'<dd>Smallest Algebraic (valid only for real symmetric problems).

          <br><dt>'be'<dd>Both ends, with one more from the high-end if <var>k</var> is odd (valid only for
real symmetric problems).

          <br><dt>'lr'<dd>Largest real part (valid only for complex or unsymmetric problems).

          <br><dt>'sr'<dd>Smallest real part (valid only for complex or unsymmetric problems).

          <br><dt>'li'<dd>Largest imaginary part (valid only for complex or unsymmetric problems).

          <br><dt>'si'<dd>Smallest imaginary part (valid only for complex or unsymmetric problems). 
</dl>

        <p>If <var>opts</var> is given, it is a structure defining some of the options that
<code>eigs</code> should use.  The fields of the structure <var>opts</var> are

          <dl>
<dt><code>issym</code><dd>If <var>af</var> is given, then flags whether the function <var>af</var> defines a
symmetric problem.  It is ignored if <var>a</var> is given.  The default is false.

          <br><dt><code>isreal</code><dd>If <var>af</var> is given, then flags whether the function <var>af</var> defines a
real problem.  It is ignored if <var>a</var> is given.  The default is true.

          <br><dt><code>tol</code><dd>Defines the required convergence tolerance, given as <code>tol * norm (A)</code>. 
The default is <code>eps</code>.

          <br><dt><code>maxit</code><dd>The maximum number of iterations.  The default is 300.

          <br><dt><code>p</code><dd>The number of Lanzcos basis vectors to use.  More vectors will result in
faster convergence, but a larger amount of memory.  The optimal value of 'p'
is problem dependent and should be in the range <var>k</var> to <var>n</var>.  The
default value is <code>2 * </code><var>k</var>.

          <br><dt><code>v0</code><dd>The starting vector for the computation.  The default is to have <span class="sc">Arpack</span>
randomly generate a starting vector.

          <br><dt><code>disp</code><dd>The level of diagnostic printout.  If <code>disp</code> is 0 then there is no
printout.  The default value is 1.

          <br><dt><code>cholB</code><dd>Flag if <code>chol (</code><var>b</var><code>)</code> is passed rather than <var>b</var>.  The default is
false.

          <br><dt><code>permB</code><dd>The permutation vector of the Cholesky factorization of <var>b</var> if
<code>cholB</code> is true.  That is <code>chol ( </code><var>b</var><code> (permB, permB))</code>.  The
default is <code>1:</code><var>n</var>.

        </dl>

        <p>It is also possible to represent <var>a</var> by a function denoted <var>af</var>. 
<var>af</var> must be followed by a scalar argument <var>n</var> defining the length
of the vector argument accepted by <var>af</var>.  <var>af</var> can be passed either
as an inline function, function handle or as a string.  In the case where
<var>af</var> is passed as a string, the name of the string defines the function
to use.

        <p><var>af</var> is a function of the form <code>function y = af (x), y = ...;
endfunction</code>, where the required return value of <var>af</var> is determined by
the value of <var>sigma</var>, and are

          <dl>
<dt><code>A * x</code><dd>If <var>sigma</var> is not given or is a string other than 'sm'.

          <br><dt><code>A \ x</code><dd>If <var>sigma</var> is 'sm'.

          <br><dt><code>(A - sigma * I) \ x</code><dd>for standard eigenvalue problem, where <code>I</code> is the identity matrix of
the same size as <code>A</code>.  If <var>sigma</var> is zero, this reduces the
<code>A \ x</code>.

          <br><dt><code>(A - sigma * B) \ x</code><dd>for the general eigenvalue problem. 
</dl>

        <p>The return arguments of <code>eigs</code> depends on the number of return
arguments.  With a single return argument, a vector <var>d</var> of length <var>k</var>
is returned, represent the <var>k</var> eigenvalues that have been found.  With two
return arguments, <var>v</var> is a <var>n</var>-by-<var>k</var> matrix whose columns are
the <var>k</var> eigenvectors corresponding to the returned eigenvalues.  The
eigenvalues themselves are then returned in <var>d</var> in the form of a
<var>n</var>-by-<var>k</var> matrix, where the elements on the diagonal are the
eigenvalues.

        <p>Given a third return argument <var>flag</var>, <code>eigs</code> also returns the status
of the convergence.  If <var>flag</var> is 0, then all eigenvalues have converged,
otherwise not.

        <p>This function is based on the <span class="sc">Arpack</span> package, written by R Lehoucq,
K Maschhoff, D Sorensen and C Yang.  For more information see
<a href="http://www.caam.rice.edu/software/ARPACK/">http://www.caam.rice.edu/software/ARPACK/</a>.

        </blockquote></div>
   <!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

<p class="noindent"><strong>See also:</strong> <a href="doc_002deig.html#doc_002deig">eig</a>, <a href="doc_002dsvds.html#doc_002dsvds">svds</a>.

<!-- ./sparse/svds.m -->
<p><a name="doc_002dsvds"></a>

<div class="defun">
&mdash; Function File: <var>s</var> = <b>svds</b> (<var>a</var>)<var><a name="index-svds-1747"></a></var><br>
&mdash; Function File: <var>s</var> = <b>svds</b> (<var>a, k</var>)<var><a name="index-svds-1748"></a></var><br>
&mdash; Function File: <var>s</var> = <b>svds</b> (<var>a, k, sigma</var>)<var><a name="index-svds-1749"></a></var><br>
&mdash; Function File: <var>s</var> = <b>svds</b> (<var>a, k, sigma, opts</var>)<var><a name="index-svds-1750"></a></var><br>
&mdash; Function File: [<var>u</var>, <var>s</var>, <var>v</var>, <var>flag</var>] = <b>svds</b> (<var><small class="dots">...</small></var>)<var><a name="index-svds-1751"></a></var><br>
<blockquote>
<p>Find a few singular values of the matrix <var>a</var>.  The singular values
are calculated using

     <pre class="example">          [<var>m</var>, <var>n</var>] = size(<var>a</var>)
          <var>s</var> = eigs([sparse(<var>m</var>, <var>m</var>), <var>a</var>; ...
                          <var>a</var>', sparse(<var>n</var>, <var>n</var>)])
     </pre>
        <p>The eigenvalues returned by <code>eigs</code> correspond to the singular
values of <var>a</var>.  The number of singular values to calculate is given
by <var>k</var>, whose default value is 6.

        <p>The argument <var>sigma</var> can be used to specify which singular values
to find.  <var>sigma</var> can be either the string 'L', the default, in
which case the largest singular values of <var>a</var> are found.  Otherwise
<var>sigma</var> should be a real scalar, in which case the singular values
closest to <var>sigma</var> are found.  Note that for relatively small values
of <var>sigma</var>, there is the chance that the requested number of singular
values are not returned.  In that case <var>sigma</var> should be increased.

        <p>If <var>opts</var> is given, then it is a structure that defines options
that <code>svds</code> will pass to <var>eigs</var>.  The possible fields of this
structure are therefore determined by <code>eigs</code>.  By default three
fields of this structure are set by <code>svds</code>.

          <dl>
<dt><code>tol</code><dd>The required convergence tolerance for the singular values.  <code>eigs</code>
is passed <var>tol</var> divided by <code>sqrt(2)</code>.  The default value is
1e-10.

          <br><dt><code>maxit</code><dd>The maximum number of iterations.  The default is 300.

          <br><dt><code>disp</code><dd>The level of diagnostic printout.  If <code>disp</code> is 0 then there is no
printout.  The default value is 0. 
</dl>

        <p>If more than one output argument is given, then <code>svds</code> also
calculates the left and right singular vectors of <var>a</var>.  <var>flag</var>
is used to signal the convergence of <code>svds</code>.  If <code>svds</code>
converges to the desired tolerance, then <var>flag</var> given by

     <pre class="example">          norm (<var>a</var> * <var>v</var> - <var>u</var> * <var>s</var>, 1) &lt;= ...
                  <var>tol</var> * norm (<var>a</var>, 1)
     </pre>
        <p>will be zero. 
</p></blockquote></div>
   <!-- Texinfo @sp should work but in practice produces ugly results for HTML. -->
<!-- A simple blank line produces the correct behavior. -->
<!-- @sp 1 -->

<p class="noindent"><strong>See also:</strong> <a href="doc_002deigs.html#doc_002deigs">eigs</a>.

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> The CHOLMOD, UMFPACK and CXSPARSE packages were
written by Tim Davis and are available at
http://www.cise.ufl.edu/research/sparse/</p>

   <p><hr></div>

   </body></html>

